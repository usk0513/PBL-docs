# チーム開発の礎を築く

## 開発環境の設計と実践

M1向け アジャイル開発PBL

---

## 今日学ぶこと

1. **なぜ環境を統一するのか？**
    - チーム開発における「共通言語」の重要性
2. **我々の戦場**
    - 本演習のアーキテクチャ概要
3. **チームの掟**
    - 技術スタックとリポジトリ運用
4. **自分の城を築く**
    - ローカル開発環境の構築
5. **実践と探求**
    - 演習課題

---

## 序章：なぜ「開発環境」から始めるのか？

---

### 「It works on my machine!」

「自分のPCでは動くのに！」
この悲痛な叫び、聞いたことありますか？

![bg right:40% fit](https://images.unsplash.com/photo-1596541223933-274776101c68?q=80&w=2832&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D)

- 開発者あるあるの笑い話
- しかし、その裏には **深刻な問題** が潜む
  - プロジェクトの遅延
  - チーム内の不信感
  - 品質低下

---

### 問題の根源：環境の「見えない差異」

![bg right:40% fit](https://images.unsplash.com/photo-1504384308006-eb1019f9ed70?q=80&w=2940&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D)

- OS、ライブラリのバージョン、設定ファイル...
- 一つ一つは些細な違いでも、積もると巨大な壁に

**チーム全員が同じ「土台」で開発できているか？**

---

### 環境構築は「共通基盤」を築く行為

![bg right:40% fit](https://images.unsplash.com/photo-1600880292203-757bb62b2baf?q=80&w=2940&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D)

- アジャイル開発における最初の、最も重要なチーム活動
- チーム全員が **同じルール、同じ言語** で対話し、協調する
- 技術的な準備作業にとどまらない
  - **チームビルディングの第一歩**

---

### 本日の目的

![bg right:40% fit](https://images.unsplash.com/photo-1621256428616-e41c4a06941a?q=80&w=2940&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D)

- 単なる手順を覚えるのではない
- **なぜ** 統一が必要かを理解する
- チームとして **最適なアプローチを自ら考え、選択する**
- そのプロセスを **ドキュメント化する**

**個人だけでなく、チームとして成果を出す基礎体力を養う**

---

## 第1部：なぜ環境を揃えるのか？

---

### チーム開発の悲劇：OSの壁

![bg right:40% fit](https://images.unsplash.com/photo-1577562548074-a6a9de9b418a?q=80&w=2940&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D)

- **パス区切り文字の違い**
  - `C:\Users\user\project` (Windows) vs `/home/user/project` (Mac/Linux)
- **デフォルトの文字コード**
  - Shift_JIS (Windows) vs UTF-8 (Mac/Linux)
  - `UnicodeDecodeError` の原因に
- **改行コードの違い**
  - CRLF (Windows) vs LF (Mac/Linux)
  - Gitの設定を誤ると無用な差分が発生

---

### チーム開発の悲劇：依存関係地獄 (Dependency Hell)

![bg right:40% fit](https://images.unsplash.com/photo-1544465243-d08316b06822?q=80&w=2940&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D)

- **グローバル環境の汚染**
  - `pip install <package>` は危険！
  - プロジェクトAとBで必要なバージョンが衝突
- **バージョンの不一致**
  - `requests` vs `requests==2.28.1`
  - わずかな違いがバグの原因に

---

### 救世主：Pythonの仮想環境（venv）

![bg right:40% fit](https://images.unsplash.com/photo-1582239634282-5c024dd9ecf0?q=80&w=2940&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D)

- プロジェクトごとに独立したPython環境を作成
- パッケージの依存関係を完全に分離
- システム全体を汚さず、安全に管理

```bash
python -m venv venv           # 仮想環境を作成
source venv/bin/activate      # 仮想環境を有効化
pip install -r requirements.txt # パッケージをインストール
```

---
### 共通言語としての requirements.txt
- プロジェクトに必要な全てのPythonパッケージとそのバージョンを記述
- バージョンは 厳密に固定 (ピン留め) する！
  - `requests==2.28.1` のように
- 作成コマンド: `pip freeze > requirements.txt`

**チーム内で共有し、常に最新を保つことが重要**

--
### 発見と学びを促すためのヒント (Why)
- 皆さんのチームは、OSが全員同じですか？
  - もし違う場合、パス区切りや文字コードの問題が起きないように、どんなルールを決めておく？
  - Gitには、改行コードを自動で統一してくれる設定があるようです。調べてみましょう。
- ローカル開発環境では SQLite、演習用VMでは PostgreSQL を使う予定です。
  - この違いが、将来どんな問題を引き起こす可能性があると思いますか？

---
### あえて教えないこと (自ら発見してほしいこと)
- データベースの差異が引き起こす問題
  - ローカルの `SQLite` とVMの `PostgreSQL` で、データ型やSQL構文に違いは？
  - 「ローカルでは動いたのに、VMでは動かない」という経験から何を学ぶ？
- より高度な依存関係管理ツール
  - `venv` + `requirements.txt` の不便さから、`Poetry` や `Pipenv` の必要性に気づけるか？
  - `pip freeze` の限界とは？

---
## 第2部：我々の戦場 – 本演習のアーキテクチャ概要

---
### ソフトウェア開発の旅路：3つの環境
1. ローカル開発環境: あなたのPC。コードを書き、テストする「作業場」。
2. 共有リポジトリ (Git): クラス全体でコードを集約・管理する「中央司令室」。
3. デプロイ先環境 (On-premise VM): 大学のサーバー。開発したプロダクトを動かす「公開ステージ」。

---
### 各環境の役割と学び
- ローカル: 個人の技術力（プログラミング、デバッグ）
- Git: チームでの協調性（バージョン管理、コンフリクト解消、コードレビュー）
- VM: 運用・インフラの知識（デプロイ、サーバー設定、環境差異の吸収）

この旅路は、あなたの成長の物語そのものです。

---
## 第3部：チームの掟 – 技術スタックとリポジトリ運用

---
### クラス全体で守るべき最低限のルール
- **技術スタック**:
  - プログラミング言語: Python 3.1x
  - Webフレームワーク: Django 5.x
- **リポジトリ構成**:
  - 全チームで 単一のGitリポジトリ を共有
  - ルート直下に team_A/, team_B/... とチームディレクトリ
  - **厳守！**: 自分のチームディレクトリ内でのみ作業すること

---
### 必須のルール：質と安全を守る
- `.gitignore` の統一
  - リポジトリルートに共通ファイルを配置
  - 不要なファイル (`__pycache__`, `db.sqlite3`, `.env`) をコミットしない
  - **機密情報漏洩防止の第一歩！**
- `requirements.txt` の配置
  - 各チームディレクトリ直下に配置し、厳密にバージョン指定
- **コーディング規約 (PEP 8)**
  - Pythonの公式スタイルガイドに準拠
  - 可読性向上、チームメンバー間の相互理解を助ける

---
### 発見と学びを促すためのヒント (How)
- チームAの settings.py にデータベースのパスワードを直書きしてしまった！
  - Gitにpushすると、クラス全員に見えてしまう。
  - **機密情報を安全に管理するにはどうすれば良い？**
  - 「Django settings secret key」で調べてみよう。
- チームAとチームBが、似たような便利機能を必要とすることに気づいた...
  - それぞれが重複して実装するべき？
  - それとも、クラス全体で再利用可能なコードをどこかに置く？
  - **モノレポのメリットを最大限に活かすには？**

---
### あえて教えないこと (自ら発見してほしいこと)
- **`settings.py` の分割と環境変数**
  - 開発/本番で設定を切り替える難しさから、分割の必要性に気づくか？
  - `python-decouple` や `os.getenv()` の有用性を体験できるか？
- **マイグレーションファイルのコンフリクト**
  - 複数人でDBスキーマ変更した際の問題。どう解決する？
  - チームでのコミュニケーションとルールの重要性を体感できるか？

---
## 第4部：自分の城を築く – ローカル開発環境の構築

---
### 推奨ルート：Dockerによる環境構築
- Dockerとは？
  - アプリケーションとその実行に必要な全てを「コンテナ」にまとめる技術
  - 「環境そのものをコードで管理する」
- なぜDockerか？
  - 環境の完全な再現性：「It works on my machine!」問題の根本解決
  - ホストOSのクリーン化: PCを汚さずに開発
  - 本番環境との近似: デプロイ時の問題を最小化

---
### Dockerの基本要素：`Dockerfile` と `docker-compose.yml`
- Dockerfile: 環境の「設計図」
```Dockerfile
FROM python:3.1x-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
```
- `docker-compose.yml`: 複数のコンテナをまとめて管理
```yml
services:
  web:
    build: .
    command: python manage.py runserver 0.0.0.0:8000
    volumes:
      - .:/app
    ports:
      - "8000:8000"
```
---
### もう一つの道：ホストOSと仮想環境 (venv)
- メリット:
  - Dockerの学習コストが不要
  - 非常に軽量に動作
- デメリット:
  - ミドルウェア (DB等) は別途手動インストール
  - 環境の完全な統一は難しい
  - OSによる差異が残りやすい

---
## 環境構築：どちらを選ぶ？ (チームで議論しよう)

どちらが良い/悪いではありません。チームのスキルレベルや目指すものを考慮して、**なぜその選択をしたのかを説明できるように**議論してください。

| 特徴 | 推奨: Dockerを利用 | 別案: venvを利用 |
| :--- | :--- | :--- |
| **環境の一貫性** | ◎ 非常に高い | △ 低い |
| **展開の容易さ** | ○ 容易 (初期学習コストあり) | △ 困難 (手順が複雑化しやすい) |
| **隔離性** | ◎ 高い | ○ 限定的 (Python環境のみ) |
| **本番環境との近さ** | ◎ 近い | × 乖離しやすい |
| **学習コスト** | △ 高い | ◎ 低い |
| **リソース消費** | △ やや大きい | ◎ 非常に小さい |

**チームの優先順位を明確にして選択しよう！**

---
### 発見と学びを促すためのヒント (What & How)
- Dockerでコンテナを起動しました。
  - 「このコンテナの中に入って、ファイルが正しくコピーされているか確認するには？」
    - `docker exec` コマンドが役立つかも。
  - 「Djangoのマイグレーション (`python manage.py migrate`) を実行したい時、コンテナに対してどう命令を送る？」
- アップロードした画像ファイルが、コンテナを再起動すると消えてしまう！
  - どこに問題がある？ `volumes` の設定はこれで十分？
  - `media/` や `static/` ディレクトリをどう扱うかチームで話し合ってみよう。

---
### あえて教えないこと (自ら発見してほしいこと)
- Dockerサンプルの「不完全性」
  - メディアファイルの永続化 (`volumes`) の必要性
  - デバッグに便利な設定 (`tty: true`, `stdin_open: true`)
  - 不完全さを体験し、自ら拡張するプロセス
- 高度なDockerテクニック
  - マルチステージビルド、セキュリティ、オーケストレーション...
  - まずは基本を徹底的に習得する

---
## 第5部：実践と探求 – 演習課題

---
### 演習1：チームの開発環境を立ち上げよ（必須）
1. アプローチ決定: Dockerかvenvか、チームで議論し決定理由も明確に。
2. Djangoプロジェクト作成: チームディレクトリ内で `django-admin startproject <project_name> .`
3. サーバー起動確認: `http://localhost:8000` でロケットが表示されることを確認。
4. 再現性確認: チーム全員が何もない状態から再現できるか相互確認。
5. ドキュメント作成: チームディレクトリ内に README.md を作成し、手順を詳細に記述。

**チームでの意思決定とドキュメンテーションの重要性を学ぶ**

---
### 演習2：なぜバージョン固定が重要なのか？（発展/思考実験）
- シナリオ:
  - 画像処理ライブラリ `ImageMagic` を利用。
  - Ver 1.5は画像形式Aを処理、Ver 2.0は画像形式Bを処理。
  - プロダクトではAとB両方扱いたい。
  - `requirements.txt` に `ImageMagic>=1.5` と記述すると、どんな問題が発生するか？
  - このジレンマを解決するアプローチは？

**依存関係の複雑な問題から、より高度なアーキテクチャの必要性を探求する**

---
### コーチングのポイント (講師向け)
- **エラーは学びの宝庫**:
  - 安易に答えを与えず、学生自身に原因究明と解決策の探求を促す
  - 「そのエラーメッセージは何を伝えようとしている？」
- **チーム間での協力の促進**:
  - 特定のチームが困っていたら、クラス全体に知見共有を呼びかける
  - 「クラス全体の成功」を実践する機会に
- **進捗の可視化と称賛**:
  - `README.md` の共有、良い例を具体的に称賛
  - 小さな成功体験がモチベーションに繋がる

---
## 質問時間

何か疑問はありますか？
